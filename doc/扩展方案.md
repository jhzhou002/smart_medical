# 扩展方案

## 🔬 增强 AI 插件的利用深度

这一部分旨在将 OpenTenBase 的 AI 插件（`opentenbase_ai`）从数据预处理工具提升为核心智能决策支持引擎，充分体现“AI 能力内置于数据库”的优势。

### 1. 历史知识库问答（RAG 增强诊断）



这是一个高级的 AI 扩展点，能显著提升诊断的可靠性和专业度。

- **目标**：在生成诊疗建议时，参考**相似历史患者**的诊断和治疗结果，使建议更具临床指导价值。
- **实现步骤**：
  1. **向量化存储**：
     - 创建新表，例如 `patient_embedding`。
     - 使用 AI 插件或外部工具将所有历史患者的**病历文本总结**、**CT 分析结果**和**诊断记录**进行嵌入（Embedding），得到向量表示。
     - 将这些向量存储在 OpenTenBase 中，利用其可能支持的**向量索引**（如 HNSW）进行优化。
  2. **PL/pgSQL RAG 流程**：
     - 在 `smart_diagnosis(patient_id)` 存储过程中，增加子流程：
       - 获取当前患者的最新病历总结向量V。
       - 使用 **OpenTenBase 的向量搜索功能**查询 `patient_embedding` 表，找到 N 个与V 最相似的历史患者 ID。
       - 提取这N 个相似患者的**最终诊断**和**治疗方案**作为上下文（Context）。
       - 调用 `ai.generate_text()`：`ai.generate_text(prompt, context)`，其中 Context 包含当前患者数据和相似患者数据。
- **价值体现**：诊断建议不再是泛泛的文本生成，而是**基于真实历史数据验证**的，增强了可解释性和准确性。



### 2. 实时影像分析与预警（数据库触发器集成）



将 AI 分析从查询时的被动调用变为数据写入时的主动处理，提高效率和实时性。

- **目标**：实现**数据写入即时分析**，而不是等待前端查询时才触发。
- **实现步骤**：
  1. **创建触发器**：在 `patient_ct_data` 表上创建一个 `BEFORE INSERT` 或 `AFTER INSERT` 触发器。
  2. **触发器逻辑（PL/pgSQL）**：
     - 当有新记录插入时，触发器自动获取该记录的 `ct_image_url`。
     - 调用 `ai.image(new.ct_image_url)` 进行影像分析。
     - 如果是 `BEFORE INSERT`，则将返回的 `ai_analysis` 结果直接写入正在插入的记录中。
  3. **扩展到其他模态**：对 `patient_text_data` 也应用相似触发器，实现 URL 传入后立即 OCR 和文本总结。
- **价值体现**：前端查询 `get_multimodal_patient_data()` 时，AI 分析结果已结构化存储在表中，查询延迟从**秒级（AI 计算）降为毫秒级（数据库查询）**，满足高性能需求。

------



## 📊 强化诊断报告的专业性与可解释性



在医疗领域，可解释性（Explainability）至关重要。医生需要知道 AI 做出判断的依据，而不是一个简单的风险分值。



### 1. 关键证据提取与引用



- **目标**：诊断报告中明确指出支持或反对某一诊断的**关键证据**，并与原始数据关联。
- **实现步骤**：
  1. **AI 增强输出**：调整 `ai.generate_text()` 的 Prompt，要求其在生成 `recommendations` 的同时，以结构化的 JSON 格式返回 `key_evidence` 数组。
  2. **证据结构**：每个证据应包含：`modality`（文本/CT/实验室）、`description`（如“WBC 15.2，高于正常范围”）、`weight`（在诊断中的重要性）、和**原始数据指针**（如 `lab_data` 中的 key 或 `ct_analysis` 的特定字段）。
  3. **前端关联**：前端报告在显示推荐时，可以点击关键证据，直接跳转或高亮显示**原始指标**或**CT 影像分析结果**。
- **价值体现**：从“黑箱诊断”转向“**证据驱动诊断**”，极大地增加了报告的专业性和医生对系统的信任。



### 2. 集成医学标准编码



- **目标**：将智能诊断结果与国际通用的医疗编码标准集成。
- **实现步骤**：
  1. **编码库**：在数据库中引入或维护一个简化的 ICD-10（国际疾病分类）或 SNOMED CT 编码表。
  2. **PL/pgSQL 映射**：在 `smart_diagnosis()` 中，让 `ai.generate_text()` 根据生成的文本描述（如肺炎、败血症）返回一个**建议的疾病名称**。
  3. **编码匹配**：存储过程利用 SQL 的 **模糊匹配** 或 **全文搜索** 功能，将 AI 建议的疾病名称与编码库进行匹配，最终在 JSON 报告中输出 `ICD_Code` 字段。
- **价值体现**：使系统具备**医疗互操作性**，结果可以直接被 HIS/PACS/LIS 等其他医疗信息系统使用，符合**“可落地应用服务”**的要求。

------



## ⚙️ 流程与性能优化建议





### 1. 性能优化：物化视图缓存统计数据



对于需要计算大量历史数据的分析功能，使用物化视图可以极大加速查询。

- **目标**：加速**异常检测**和**趋势分析**中的历史数据聚合计算。

- **实现步骤**：

  1. **创建物化视图**：创建一个 MV，例如 `lab_stats_mv`，存储每个指标的历史均值μ和标准差σ。

  2. **刷新策略**：设置定期（例如每晚）或在批量数据导入后刷新该物化视图。

     SQL

     ```
     CREATE MATERIALIZED VIEW lab_stats_mv AS
     SELECT indicator, AVG(value) as historical_avg, STDDEV(value) as historical_stddev
     FROM patient_lab_data, jsonb_each_text(lab_data) AS lab
     GROUP BY indicator;
     
     REFRESH MATERIALIZED VIEW lab_stats_mv;
     ```

  3. **函数调用优化**：修改 `detect_lab_anomaly()` 存储过程，使其直接查询 `lab_stats_mv` 获取 μ和σ，避免对原始历史数据进行昂贵的聚合操作。



### 2. PL/pgSQL 模块化与错误处理



- **目标**：提高 **409 行**存储过程的可维护性、健壮性和专业度。
- **优化点**：
  1. **原子化函数**：将通用逻辑（如 JSONB 字段提取、Z-score 计算、时间序列 LAG() 逻辑）重构为单独的、小的 PL/pgSQL 函数。
  2. **错误处理**：在关键存储过程（如 `smart_diagnosis`）中加入 **`EXCEPTION` 块**，对数据库连接失败、AI 插件返回空值或 JSON 解析错误进行捕获和记录，并返回清晰的错误信息，而不是直接抛出系统异常。
  3. **日志记录**：利用 OpenTenBase 的日志函数，在存储过程中记录关键步骤和 AI 插件调用的时间和状态，以便于**性能分析和故障排查**。