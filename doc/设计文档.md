# 医疗多模态智能分析平台 - 设计文档

## 目录

- [1. 系统概述](#1-系统概述)
- [2. 架构设计](#2-架构设计)
- [3. 数据库设计](#3-数据库设计)
- [4. 核心算法设计](#4-核心算法设计)
- [5. API 设计](#5-api-设计)
- [6. 前端设计](#6-前端设计)
- [7. 性能优化](#7-性能优化)
- [8. 安全设计](#8-安全设计)

---

## 1. 系统概述

### 1.1 项目背景

医疗数据分析面临的核心挑战：
- **多模态数据整合难度大**：病历文本、CT影像、实验室指标格式各异
- **传统 AI 调用低效**：外部 API 调用延迟高，网络往返多
- **数据孤岛问题**：各模态数据分散存储，关联分析困难

本项目创新点：
- **AI 能力内置数据库**：通过 OpenTenBase AI 插件，AI 分析在数据库层完成
- **PL/pgSQL 智能分析引擎**：982 行存储过程代码，实现多模态数据的结构化关联分析
- **异步任务队列**：长时间 AI 分析不阻塞前端，流畅用户体验

### 1.2 技术选型理由

| 技术 | 选型理由 |
|-----|---------|
| **OpenTenBase** | 分布式 PostgreSQL，支持 AI 插件，数据库内 AI 调用 |
| **opentenbase_ai** | 内置 AI 能力，减少 75% 网络往返，性能提升显著 |
| **PL/pgSQL** | 数据库原生语言，逻辑内置数据库，安全高效 |
| **Vue 3** | Composition API，组件化开发，响应式状态管理 |
| **Node.js** | 异步高性能，生态丰富，前后端统一语言 |
| **七牛云** | CDN 加速，对象存储，图片访问快速稳定 |

### 1.3 核心功能模块

```
┌─────────────────────────────────────────────────────┐
│                   系统功能架构                        │
├─────────────────────────────────────────────────────┤
│  患者管理           数据上传           智能分析       │
│  - 新增患者         - 病历文本         - 多模态融合   │
│  - 搜索患者         - CT 影像          - 异常检测     │
│  - 患者详情         - 实验室指标       - 证据溯源     │
│                                                       │
│  报告导出           任务队列           用户认证       │
│  - PDF 生成         - 异步分析         - JWT 登录     │
│  - 分析报告         - 状态查询         - 权限管理     │
└─────────────────────────────────────────────────────┘
```

---

## 2. 架构设计

### 2.1 总体架构

```
┌────────────────────────────────────────────────────────┐
│                      前端层                             │
│  Vue 3 + Pinia + Element Plus + TailwindCSS            │
│  ┌──────────┬──────────┬──────────┬──────────┐       │
│  │患者管理  │数据上传  │智能分析  │报告导出  │       │
│  └──────────┴──────────┴──────────┴──────────┘       │
└────────────────────────────────────────────────────────┘
                        ↓ HTTP REST API
┌────────────────────────────────────────────────────────┐
│                      后端层                             │
│  Node.js + Express + Winston                           │
│  ┌──────────────────────────────────────────────┐     │
│  │  API 路由层                                   │     │
│  │  - /api/patients - 患者管理                   │     │
│  │  - /api/text-analysis - 病历分析              │     │
│  │  - /api/ct-analysis - CT 分析                 │     │
│  │  - /api/lab-analysis - 实验室指标             │     │
│  │  - /api/db-analysis - 数据库端分析（核心）    │     │
│  └──────────────────────────────────────────────┘     │
│  ┌──────────────────────────────────────────────┐     │
│  │  业务服务层                                   │     │
│  │  - opentenbase-ai.js - AI 调用封装           │     │
│  │  - qiniu.js - 七牛云上传                      │     │
│  └──────────────────────────────────────────────┘     │
└────────────────────────────────────────────────────────┘
                        ↓ SQL
┌────────────────────────────────────────────────────────┐
│                    数据库层                             │
│  OpenTenBase (PostgreSQL 分布式版本)                   │
│  ┌──────────────────────────────────────────────┐     │
│  │  PL/pgSQL 智能分析引擎（982 行代码）          │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ get_multimodal_data()               │    │     │
│  │  │ - 多模态数据统一查询                │    │     │
│  │  │ - LATERAL JOIN 关联分析             │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ calculate_data_quality_weights()    │    │     │
│  │  │ - 数据质量评估                      │    │     │
│  │  │ - 动态权重计算                      │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ analyze_lab_anomalies()             │    │     │
│  │  │ - σ偏离度计算                       │    │     │
│  │  │ - 三级严重程度分级                  │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ extract_key_evidence()              │    │     │
│  │  │ - 证据提取                          │    │     │
│  │  │ - 权重计算                          │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ calibrate_confidence()              │    │     │
│  │  │ - 置信度校准（92% 硬性上限）        │    │     │
│  │  │ - 保守策略                          │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ generate_smart_diagnosis()          │    │     │
│  │  │ - 调用 AI 插件生成诊断              │    │     │
│  │  │ - 结构化结果解析                    │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  │                                               │     │
│  │  ┌─────────────────────────────────────┐    │     │
│  │  │ smart_diagnosis()                   │    │     │
│  │  │ - 主流程编排                        │    │     │
│  │  │ - 异步任务管理                      │    │     │
│  │  └─────────────────────────────────────┘    │     │
│  └──────────────────────────────────────────────┘     │
│  ┌──────────────────────────────────────────────┐     │
│  │  AI 插件 (opentenbase_ai)                    │     │
│  │  - ai.image(prompt, url) - OCR/图像分析      │     │
│  │  - ai.generate_text(prompt) - 文本生成       │     │
│  │  - ai.completion() - 多模态融合               │     │
│  └──────────────────────────────────────────────┘     │
└────────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────────┐
│                    云存储层                             │
│  七牛云对象存储 + CDN                                   │
│  - 病历图片: /opentenbase/text/                        │
│  - CT 影像: /opentenbase/CT/                           │
│  - 实验室指标: /opentenbase/structure/                 │
└────────────────────────────────────────────────────────┘
```

### 2.2 数据流转

#### 典型业务流程：智能诊断

```
用户发起请求
    ↓
前端调用 API: POST /api/db-analysis/smart-diagnosis
    ↓
后端路由转发: database-analysis.js
    ↓
调用存储过程: SELECT smart_diagnosis(patient_id)
    ↓
┌──────────────────────────────────────────────────┐
│  数据库内执行 PL/pgSQL 流程                       │
│  1. 创建异步任务记录                              │
│  2. 查询多模态数据 (get_multimodal_data)          │
│  3. 计算数据质量权重 (calculate_data_quality...)  │
│  4. 异常检测 (analyze_lab_anomalies)              │
│  5. 提取关键证据 (extract_key_evidence)           │
│  6. 调用 AI 生成诊断 (generate_smart_diagnosis)   │
│  7. 置信度校准 (calibrate_confidence)             │
│  8. 保存诊断结果到 patient_diagnosis              │
│  9. 更新任务状态为 completed                      │
└──────────────────────────────────────────────────┘
    ↓
返回任务 ID + 初步结果
    ↓
前端轮询任务状态: GET /api/db-analysis/task-status/:taskId
    ↓
任务完成后展示完整诊断结果
```

### 2.3 关键设计原则

**1. AI 能力下沉到数据库层**
- 传统方案：应用层 → 数据库查询 → 应用层 → 外部 AI API → 应用层 → 数据库写入
- 本项目：应用层 → 数据库（内部完成 AI 调用 + 数据分析） → 应用层
- **优势**：减少 75% 网络往返，延迟降低，吞吐量提升

**2. 异步任务队列**
- AI 分析耗时可达 30-60 秒
- 前端发起请求后立即返回任务 ID
- 前端轮询任务状态
- 后台完成分析后更新任务状态

**3. 数据驱动的动态加权**
- 不同患者数据完整度差异大
- 根据数据质量动态调整各模态权重
- 确保分析结果可靠性

---

## 3. 数据库设计

### 3.1 核心数据表

#### 3.1.1 患者基本信息表 (patients)

```sql
CREATE TABLE patients (
    patient_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    age INT CHECK (age > 0 AND age < 150),
    gender VARCHAR(10) CHECK (gender IN ('男', '女', '其他')),
    first_visit BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_patients_name ON patients(name);
CREATE INDEX idx_patients_created_at ON patients(created_at);
```

**字段说明**：
- `patient_id`: 主键，全局唯一患者标识
- `first_visit`: 标识是否为首次就诊（影响数据录入流程）

#### 3.1.2 病历文本数据表 (patient_text_data)

```sql
CREATE TABLE patient_text_data (
    id SERIAL PRIMARY KEY,
    patient_id INT NOT NULL,
    image_url TEXT NOT NULL,
    ocr_text TEXT,
    summary TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (patient_id) REFERENCES patients(patient_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_patient_text_patient_id ON patient_text_data(patient_id);
```

**字段说明**：
- `ocr_text`: AI 插件识别的原始文本
- `summary`: AI 生成的病历摘要（用于智能分析）

#### 3.1.3 CT 影像数据表 (patient_ct_data)

```sql
CREATE TABLE patient_ct_data (
    id SERIAL PRIMARY KEY,
    patient_id INT NOT NULL,
    original_image_url TEXT NOT NULL,
    segmented_image_url TEXT,
    body_part VARCHAR(50),
    analysis_result TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (patient_id) REFERENCES patients(patient_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_patient_ct_patient_id ON patient_ct_data(patient_id);
```

**字段说明**：
- `original_image_url`: 原始 CT 图片
- `segmented_image_url`: 分割强化后的图片（突出病灶）
- `body_part`: 检查部位（lung/liver/kidney/brain）

#### 3.1.4 实验室指标数据表 (patient_lab_data)

```sql
CREATE TABLE patient_lab_data (
    id SERIAL PRIMARY KEY,
    patient_id INT NOT NULL,
    image_url TEXT NOT NULL,
    indicators JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (patient_id) REFERENCES patients(patient_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_patient_lab_patient_id ON patient_lab_data(patient_id);
CREATE INDEX idx_patient_lab_indicators ON patient_lab_data USING GIN(indicators);
```

**JSONB 格式示例**：
```json
{
    "血常规": {
        "白细胞计数": {"value": 12.5, "unit": "10^9/L", "range": "4-10"},
        "红细胞计数": {"value": 4.2, "unit": "10^12/L", "range": "3.5-5.5"}
    },
    "肝功能": {
        "ALT": {"value": 85, "unit": "U/L", "range": "0-40"},
        "AST": {"value": 72, "unit": "U/L", "range": "0-40"}
    }
}
```

#### 3.1.5 诊断记录表 (patient_diagnosis)

```sql
CREATE TABLE patient_diagnosis (
    id SERIAL PRIMARY KEY,
    patient_id INT NOT NULL,
    diagnosis_text TEXT NOT NULL,
    evidence_json JSONB,
    confidence NUMERIC(5,2) CHECK (confidence >= 0 AND confidence <= 100),
    risk_score NUMERIC(5,2),
    anomalies JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (patient_id) REFERENCES patients(patient_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_patient_diagnosis_patient_id ON patient_diagnosis(patient_id);
CREATE INDEX idx_patient_diagnosis_created_at ON patient_diagnosis(created_at);
CREATE INDEX idx_patient_diagnosis_evidence ON patient_diagnosis USING GIN(evidence_json);
```

**evidence_json 格式示例**：
```json
{
    "key_findings": [
        {
            "type": "text",
            "content": "患者主诉胸痛3天",
            "weight": 0.35,
            "source": "病历摘要"
        },
        {
            "type": "ct",
            "content": "左肺下叶见片状阴影",
            "weight": 0.40,
            "source": "CT 影像"
        },
        {
            "type": "lab",
            "content": "白细胞计数 12.5 (↑)",
            "weight": 0.25,
            "source": "实验室指标"
        }
    ]
}
```

**anomalies 格式示例**：
```json
{
    "严重": [
        {
            "indicator": "ALT",
            "value": 85,
            "normal_range": "0-40",
            "deviation": 2.8,
            "severity": "严重"
        }
    ],
    "中度": [],
    "轻微": []
}
```

#### 3.1.6 异步任务表 (analysis_tasks)

```sql
CREATE TABLE analysis_tasks (
    id SERIAL PRIMARY KEY,
    patient_id INT NOT NULL,
    task_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    result JSONB,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (patient_id) REFERENCES patients(patient_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_analysis_tasks_patient_id ON analysis_tasks(patient_id);
CREATE INDEX idx_analysis_tasks_status ON analysis_tasks(status);
```

**status 状态流转**：
```
pending → processing → completed / failed
```

### 3.2 数据表关系图

```
                    ┌──────────────┐
                    │   patients   │
                    │ (患者主表)   │
                    └──────┬───────┘
                           │ 1
                           │
        ┌──────────────────┼──────────────────┬──────────────────┐
        │                  │                  │                  │
        │ N                │ N                │ N                │ N
┌───────▼────────┐ ┌───────▼────────┐ ┌──────▼───────┐ ┌───────▼────────┐
│patient_text_   │ │patient_ct_     │ │patient_lab_  │ │patient_        │
│    data        │ │    data        │ │    data      │ │ diagnosis      │
│ (病历文本)     │ │ (CT 影像)      │ │(实验室指标)  │ │  (诊断结果)    │
└────────────────┘ └────────────────┘ └──────────────┘ └────────────────┘

                    ┌──────────────┐
                    │ analysis_    │
                    │   tasks      │
                    │ (异步任务)   │
                    └──────────────┘
```

### 3.3 分片键设计（OpenTenBase 分布式）

**分片策略**：使用 `patient_id` 作为分片键

```sql
-- 创建分片表示例
CREATE TABLE patients (
    ...
) DISTRIBUTE BY SHARD(patient_id);

CREATE TABLE patient_text_data (
    ...
) DISTRIBUTE BY SHARD(patient_id);
```

**设计理由**：
1. 所有查询都基于 `patient_id`，避免跨节点查询
2. 单患者数据聚合在同一节点，JOIN 性能最优
3. 数据分布均匀，负载均衡

**查询优化原则**：
```sql
-- ✅ 高效查询（带分片键）
SELECT * FROM patient_text_data WHERE patient_id = 123;

-- ❌ 低效查询（不带分片键，全节点扫描）
SELECT * FROM patient_text_data WHERE id = 456;
```

---

## 4. 核心算法设计

### 4.1 多模态数据质量动态加权算法

#### 算法思路

不同患者数据完整度差异大：
- 患者 A：有完整病历 + CT + 实验室指标
- 患者 B：只有病历和 CT，无实验室指标

传统固定权重方案（病历 30% + CT 40% + 指标 30%）在患者 B 无实验室指标时会导致：
- 无指标数据，30% 权重浪费
- 剩余 70% 权重被病历和 CT 分摊，但比例失衡

**动态加权方案**：
1. 评估各模态数据质量（完整性、时效性）
2. 根据数据质量动态调整权重
3. 缺失模态权重自动分配给其他模态

#### PL/pgSQL 实现

```sql
CREATE OR REPLACE FUNCTION calculate_data_quality_weights(
    p_patient_id INT,
    p_text_summary TEXT,
    p_ct_analysis TEXT,
    p_lab_json JSONB
)
RETURNS JSONB AS $$
DECLARE
    v_text_weight NUMERIC := 0;
    v_ct_weight NUMERIC := 0;
    v_lab_weight NUMERIC := 0;
    v_total_weight NUMERIC := 0;
BEGIN
    -- 1. 评估病历文本质量
    IF p_text_summary IS NOT NULL AND LENGTH(p_text_summary) > 50 THEN
        v_text_weight := 30;
    ELSIF p_text_summary IS NOT NULL THEN
        v_text_weight := 15;
    END IF;

    -- 2. 评估 CT 影像质量
    IF p_ct_analysis IS NOT NULL AND LENGTH(p_ct_analysis) > 50 THEN
        v_ct_weight := 40;
    ELSIF p_ct_analysis IS NOT NULL THEN
        v_ct_weight := 20;
    END IF;

    -- 3. 评估实验室指标质量
    IF p_lab_json IS NOT NULL AND jsonb_array_length(p_lab_json) > 0 THEN
        v_lab_weight := 30;
    END IF;

    -- 4. 归一化权重
    v_total_weight := v_text_weight + v_ct_weight + v_lab_weight;

    IF v_total_weight > 0 THEN
        v_text_weight := v_text_weight / v_total_weight;
        v_ct_weight := v_ct_weight / v_total_weight;
        v_lab_weight := v_lab_weight / v_total_weight;
    END IF;

    -- 5. 返回权重分布
    RETURN jsonb_build_object(
        'text_weight', v_text_weight,
        'ct_weight', v_ct_weight,
        'lab_weight', v_lab_weight,
        'total_quality_score', v_total_weight
    );
END;
$$ LANGUAGE plpgsql;
```

#### 示例场景

**场景 1：完整数据**
- 输入：病历摘要 200 字 + CT 分析 150 字 + 实验室指标 10 项
- 输出：text_weight=0.30, ct_weight=0.40, lab_weight=0.30

**场景 2：缺失实验室指标**
- 输入：病历摘要 200 字 + CT 分析 150 字 + 无实验室指标
- 输出：text_weight=0.43, ct_weight=0.57, lab_weight=0.00

### 4.2 实验室指标异常严重程度分级算法

#### 算法原理：σ 偏离度（Z-score）

**公式**：
```
σ偏离度 = |实际值 - 正常范围中值| / 正常范围标准差

标准差估算：
σ ≈ (正常上限 - 正常下限) / 4
```

**分级标准**：
- 轻微异常：0 < σ偏离度 ≤ 1.5（偏离度 ≤ 1.5σ）
- 中度异常：1.5 < σ偏离度 ≤ 2.5（偏离度 1.5-2.5σ）
- 严重异常：σ偏离度 > 2.5（偏离度 > 2.5σ）

#### PL/pgSQL 实现

```sql
CREATE OR REPLACE FUNCTION analyze_lab_anomalies(
    p_lab_json JSONB
)
RETURNS JSONB AS $$
DECLARE
    v_anomalies JSONB := '{"轻微": [], "中度": [], "严重": []}'::JSONB;
    v_category TEXT;
    v_indicator TEXT;
    v_value NUMERIC;
    v_range TEXT;
    v_min NUMERIC;
    v_max NUMERIC;
    v_mid NUMERIC;
    v_sigma NUMERIC;
    v_deviation NUMERIC;
    v_severity TEXT;
BEGIN
    -- 遍历所有指标分类
    FOR v_category IN SELECT jsonb_object_keys(p_lab_json)
    LOOP
        -- 遍历该分类下的所有指标
        FOR v_indicator, v_value, v_range IN
            SELECT
                key,
                (value->>'value')::NUMERIC,
                value->>'range'
            FROM jsonb_each(p_lab_json->v_category)
        LOOP
            -- 解析正常范围
            v_min := split_part(v_range, '-', 1)::NUMERIC;
            v_max := split_part(v_range, '-', 2)::NUMERIC;
            v_mid := (v_min + v_max) / 2;
            v_sigma := (v_max - v_min) / 4;

            -- 计算 σ 偏离度
            v_deviation := ABS(v_value - v_mid) / v_sigma;

            -- 判断是否异常
            IF v_value < v_min OR v_value > v_max THEN
                -- 确定严重程度
                IF v_deviation <= 1.5 THEN
                    v_severity := '轻微';
                ELSIF v_deviation <= 2.5 THEN
                    v_severity := '中度';
                ELSE
                    v_severity := '严重';
                END IF;

                -- 添加到对应数组
                v_anomalies := jsonb_set(
                    v_anomalies,
                    ARRAY[v_severity],
                    (v_anomalies->v_severity) || jsonb_build_object(
                        'category', v_category,
                        'indicator', v_indicator,
                        'value', v_value,
                        'normal_range', v_range,
                        'deviation', ROUND(v_deviation, 2),
                        'severity', v_severity
                    )
                );
            END IF;
        END LOOP;
    END LOOP;

    RETURN v_anomalies;
END;
$$ LANGUAGE plpgsql;
```

#### 示例场景

**输入**：
```json
{
    "肝功能": {
        "ALT": {"value": 85, "range": "0-40"},
        "AST": {"value": 72, "range": "0-40"}
    }
}
```

**计算过程**：
- ALT: mid=20, σ=10, deviation = |85-20|/10 = 6.5 → 严重
- AST: mid=20, σ=10, deviation = |72-20|/10 = 5.2 → 严重

**输出**：
```json
{
    "严重": [
        {"indicator": "ALT", "value": 85, "deviation": 6.5},
        {"indicator": "AST", "value": 72, "deviation": 5.2}
    ]
}
```

### 4.3 置信度校准算法

#### 问题背景

AI 生成的诊断置信度往往过度自信：
- AI 返回 98% 置信度，但实际可能只有 85%
- 医疗场景需要保守策略，永不应达到 100%

#### 校准策略

**1. 基础校准公式**：
```
校准后置信度 = 原始置信度 × 校准因子
```

**2. 保守策略**：
- 缺失模态数据 → 降低置信度
- 数据质量差 → 降低置信度
- 硬性上限：92%（永不达 100%）

#### PL/pgSQL 实现

```sql
CREATE OR REPLACE FUNCTION calibrate_confidence(
    p_raw_confidence NUMERIC,
    p_data_quality_score NUMERIC,
    p_modality_count INT
)
RETURNS NUMERIC AS $$
DECLARE
    v_calibrated NUMERIC;
    v_quality_factor NUMERIC;
    v_modality_factor NUMERIC;
BEGIN
    -- 1. 数据质量因子（0.7 - 1.0）
    v_quality_factor := 0.7 + (p_data_quality_score / 100.0) * 0.3;

    -- 2. 模态完整性因子
    CASE
        WHEN p_modality_count >= 3 THEN v_modality_factor := 1.0;
        WHEN p_modality_count = 2 THEN v_modality_factor := 0.9;
        ELSE v_modality_factor := 0.8;
    END CASE;

    -- 3. 综合校准
    v_calibrated := p_raw_confidence * v_quality_factor * v_modality_factor;

    -- 4. 硬性上限 92%
    IF v_calibrated > 92 THEN
        v_calibrated := 92;
    END IF;

    RETURN ROUND(v_calibrated, 2);
END;
$$ LANGUAGE plpgsql;
```

#### 示例场景

**场景 1：完整数据 + 高质量**
- 输入：raw_confidence=95, quality_score=90, modality_count=3
- 计算：95 × 0.97 × 1.0 = 92.15 → 92%（上限截断）

**场景 2：缺失模态 + 中等质量**
- 输入：raw_confidence=88, quality_score=60, modality_count=2
- 计算：88 × 0.88 × 0.9 = 69.70 → 69.70%

### 4.4 关键证据提取算法

#### 提取策略

**1. 从病历摘要提取**：
- 主诉、现病史中的关键症状
- 权重：30-35%

**2. 从 CT 分析提取**：
- 影像学阳性发现（病灶、结节、阴影）
- 权重：40-45%

**3. 从实验室指标提取**：
- 严重异常指标（σ偏离度 > 2.5）
- 权重：25-30%

#### PL/pgSQL 实现

```sql
CREATE OR REPLACE FUNCTION extract_key_evidence(
    p_text_summary TEXT,
    p_ct_analysis TEXT,
    p_lab_anomalies JSONB,
    p_weights JSONB
)
RETURNS JSONB AS $$
DECLARE
    v_evidence JSONB := '[]'::JSONB;
    v_anomaly JSONB;
BEGIN
    -- 1. 提取病历关键信息
    IF p_text_summary IS NOT NULL THEN
        v_evidence := v_evidence || jsonb_build_array(jsonb_build_object(
            'type', 'text',
            'content', LEFT(p_text_summary, 100),
            'weight', p_weights->>'text_weight',
            'source', '病历摘要'
        ));
    END IF;

    -- 2. 提取 CT 关键发现
    IF p_ct_analysis IS NOT NULL THEN
        v_evidence := v_evidence || jsonb_build_array(jsonb_build_object(
            'type', 'ct',
            'content', LEFT(p_ct_analysis, 100),
            'weight', p_weights->>'ct_weight',
            'source', 'CT 影像'
        ));
    END IF;

    -- 3. 提取严重异常指标
    FOR v_anomaly IN SELECT * FROM jsonb_array_elements(p_lab_anomalies->'严重')
    LOOP
        v_evidence := v_evidence || jsonb_build_array(jsonb_build_object(
            'type', 'lab',
            'content', v_anomaly->>'indicator' || ': ' || v_anomaly->>'value' || ' (↑)',
            'weight', (p_weights->>'lab_weight')::NUMERIC / jsonb_array_length(p_lab_anomalies->'严重'),
            'source', '实验室指标'
        ));
    END LOOP;

    RETURN jsonb_build_object('key_findings', v_evidence);
END;
$$ LANGUAGE plpgsql;
```

---

## 5. API 设计

### 5.1 RESTful API 规范

**统一响应格式**：
```json
{
    "success": true/false,
    "data": { ... },
    "error": "错误信息"
}
```

**HTTP 状态码**：
- 200: 成功
- 201: 创建成功
- 400: 参数错误
- 401: 未认证
- 403: 无权限
- 404: 资源不存在
- 500: 服务器错误

### 5.2 核心 API 端点

#### 5.2.1 患者管理

**创建患者**：
```
POST /api/patients
Content-Type: application/json

Request Body:
{
    "name": "张三",
    "age": 45,
    "gender": "男",
    "first_visit": true
}

Response:
{
    "success": true,
    "data": {
        "patient_id": 123,
        "name": "张三",
        "created_at": "2025-10-16T10:30:00Z"
    }
}
```

**搜索患者**：
```
GET /api/patients?name=张三&page=1&limit=10

Response:
{
    "success": true,
    "data": {
        "patients": [...],
        "total": 25,
        "page": 1,
        "limit": 10
    }
}
```

#### 5.2.2 数据上传

**病历文本上传**：
```
POST /api/text-analysis
Content-Type: multipart/form-data

Request:
- image: 病历图片文件
- patient_id: 123

Response:
{
    "success": true,
    "data": {
        "image_url": "https://qiniu.../text/xxx.jpg",
        "ocr_text": "患者主诉...",
        "summary": "AI 生成的病历摘要"
    }
}
```

**CT 影像上传**：
```
POST /api/ct-analysis
Content-Type: multipart/form-data

Request:
- image: CT 图片文件
- patient_id: 123
- body_part: "lung"

Response:
{
    "success": true,
    "data": {
        "original_image_url": "https://qiniu.../CT/xxx.jpg",
        "segmented_image_url": "https://qiniu.../CT/xxx_seg.jpg",
        "analysis_result": "影像学诊断..."
    }
}
```

#### 5.2.3 智能诊断（核心 API）

**发起智能诊断**：
```
POST /api/db-analysis/smart-diagnosis
Content-Type: application/json

Request Body:
{
    "patient_id": 123
}

Response:
{
    "success": true,
    "data": {
        "task_id": "task_456",
        "status": "processing",
        "estimated_time": 60
    }
}
```

**查询任务状态**：
```
GET /api/db-analysis/task-status/task_456

Response (处理中):
{
    "success": true,
    "data": {
        "status": "processing",
        "progress": 45
    }
}

Response (完成):
{
    "success": true,
    "data": {
        "status": "completed",
        "result": {
            "diagnosis_text": "初步诊断...",
            "confidence": 85.50,
            "risk_score": 72.30,
            "evidence": {...},
            "anomalies": {...}
        }
    }
}
```

#### 5.2.4 多模态数据查询

**统一查询接口**：
```
GET /api/db-analysis/multimodal/:patient_id

Response:
{
    "success": true,
    "data": {
        "patient": {...},
        "text_data": [{...}],
        "ct_data": [{...}],
        "lab_data": [{...}],
        "diagnosis": [{...}]
    }
}
```

### 5.3 认证与权限

**JWT 认证流程**：
```
1. 用户登录: POST /api/auth/login
   → 返回 JWT Token

2. 后续请求携带 Token:
   Authorization: Bearer <token>

3. 后端中间件验证 Token
   → 提取 user_id
   → 执行业务逻辑
```

**中间件实现** (backend/src/middleware/auth.js):
```javascript
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
        return res.status(401).json({
            success: false,
            error: '未提供认证令牌'
        });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(401).json({
            success: false,
            error: '无效的认证令牌'
        });
    }
};
```

---

## 6. 前端设计

### 6.1 技术栈

- **框架**: Vue 3 (Composition API)
- **状态管理**: Pinia
- **UI 组件库**: Element Plus + Ant Design Vue
- **样式**: TailwindCSS
- **路由**: Vue Router
- **HTTP 客户端**: Axios
- **PDF 生成**: jsPDF / pdfmake

### 6.2 页面结构

```
┌────────────────────────────────────────────────┐
│              Layout.vue (主布局)                │
│  ┌──────────────────────────────────────────┐ │
│  │  顶部导航栏 (Header)                      │ │
│  │  - Logo                                   │ │
│  │  - 导航菜单                               │ │
│  │  - 用户信息                               │ │
│  └──────────────────────────────────────────┘ │
│  ┌───────┬──────────────────────────────────┐ │
│  │侧边栏 │      主内容区 (Router View)       │ │
│  │       │  ┌────────────────────────────┐  │ │
│  │- 患者 │  │  PatientManagement.vue     │  │ │
│  │  管理 │  │  DataUpload.vue            │  │ │
│  │- 数据 │  │  AIAnalysis.vue            │  │ │
│  │  上传 │  │  DiagnosisReports.vue      │  │ │
│  │- 智能 │  └────────────────────────────┘  │ │
│  │  分析 │                                   │ │
│  │- 诊断 │                                   │ │
│  │  报告 │                                   │ │
│  └───────┴──────────────────────────────────┘ │
└────────────────────────────────────────────────┘
```

### 6.3 核心组件设计

#### 6.3.1 智能诊断面板 (SmartDiagnosisPanel.vue)

**功能**：
- 发起智能诊断
- 实时显示任务状态
- 展示诊断结果

**组件结构**：
```vue
<template>
  <div class="diagnosis-panel">
    <!-- 发起诊断按钮 -->
    <el-button
      type="primary"
      @click="startDiagnosis"
      :loading="isProcessing">
      开始智能诊断
    </el-button>

    <!-- 进度条 -->
    <el-progress
      v-if="isProcessing"
      :percentage="progress"
      :status="progressStatus" />

    <!-- 诊断结果 -->
    <div v-if="diagnosisResult" class="result-container">
      <h3>诊断结论</h3>
      <p>{{ diagnosisResult.diagnosis_text }}</p>

      <div class="metrics">
        <div class="metric-item">
          <span>置信度</span>
          <el-progress
            type="circle"
            :percentage="diagnosisResult.confidence" />
        </div>
        <div class="metric-item">
          <span>风险评分</span>
          <el-progress
            type="circle"
            :percentage="diagnosisResult.risk_score"
            color="#f56c6c" />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { startSmartDiagnosis, pollTaskStatus } from '@/api/diagnosis';

const isProcessing = ref(false);
const progress = ref(0);
const diagnosisResult = ref(null);

const startDiagnosis = async () => {
  isProcessing.value = true;

  // 发起诊断
  const { task_id } = await startSmartDiagnosis(patientId);

  // 轮询任务状态
  const interval = setInterval(async () => {
    const { status, result } = await pollTaskStatus(task_id);

    if (status === 'completed') {
      clearInterval(interval);
      isProcessing.value = false;
      diagnosisResult.value = result;
    } else if (status === 'failed') {
      clearInterval(interval);
      isProcessing.value = false;
      ElMessage.error('诊断失败');
    } else {
      progress.value += 5; // 模拟进度
    }
  }, 2000);
};
</script>
```

#### 6.3.2 异常检测组件 (AnomalyDetection.vue)

**功能**：
- 分级展示异常指标（严重/中度/轻微）
- 高亮严重异常
- 可视化偏离度

**组件结构**：
```vue
<template>
  <div class="anomaly-detection">
    <h3>实验室指标异常</h3>

    <!-- 严重异常 -->
    <el-collapse v-model="activeNames">
      <el-collapse-item
        name="severe"
        title="严重异常"
        :disabled="!anomalies.严重?.length">

        <el-table :data="anomalies.严重" stripe>
          <el-table-column prop="indicator" label="指标" />
          <el-table-column prop="value" label="检测值" />
          <el-table-column prop="normal_range" label="正常范围" />
          <el-table-column label="偏离度">
            <template #default="{ row }">
              <el-tag type="danger">
                {{ row.deviation }}σ
              </el-tag>
            </template>
          </el-table-column>
        </el-table>
      </el-collapse-item>

      <!-- 中度异常 -->
      <el-collapse-item
        name="moderate"
        title="中度异常">
        <!-- 类似结构 -->
      </el-collapse-item>

      <!-- 轻微异常 -->
      <el-collapse-item
        name="mild"
        title="轻微异常">
        <!-- 类似结构 -->
      </el-collapse-item>
    </el-collapse>
  </div>
</template>

<script setup>
const props = defineProps({
  anomalies: Object
});

const activeNames = ref(['severe']);
</script>
```

### 6.4 状态管理 (Pinia)

**患者状态** (stores/patient.js):
```javascript
import { defineStore } from 'pinia';

export const usePatientStore = defineStore('patient', {
  state: () => ({
    currentPatient: null,
    patientList: [],
    searchQuery: ''
  }),

  actions: {
    async fetchPatients(query) {
      const response = await api.get('/api/patients', { params: query });
      this.patientList = response.data.patients;
    },

    async selectPatient(patientId) {
      const response = await api.get(`/api/patients/${patientId}`);
      this.currentPatient = response.data;
    }
  },

  getters: {
    currentPatientId: (state) => state.currentPatient?.patient_id
  }
});
```

---

## 7. 性能优化

### 7.1 数据库层优化

**1. 索引优化**：
```sql
-- 高频查询字段添加索引
CREATE INDEX idx_patients_name ON patients(name);
CREATE INDEX idx_patient_text_patient_id ON patient_text_data(patient_id);

-- JSONB 字段使用 GIN 索引
CREATE INDEX idx_patient_lab_indicators ON patient_lab_data USING GIN(indicators);
```

**2. 查询优化**：
```sql
-- ✅ 使用分片键查询
SELECT * FROM patient_text_data WHERE patient_id = $1;

-- ✅ 使用 LATERAL JOIN 提升多模态关联查询性能
SELECT p.*, t.summary, c.analysis_result
FROM patients p
LEFT JOIN LATERAL (
  SELECT summary FROM patient_text_data
  WHERE patient_id = p.patient_id
  ORDER BY created_at DESC LIMIT 1
) t ON TRUE
LEFT JOIN LATERAL (
  SELECT analysis_result FROM patient_ct_data
  WHERE patient_id = p.patient_id
  ORDER BY created_at DESC LIMIT 1
) c ON TRUE
WHERE p.patient_id = $1;
```

**3. 连接池管理**：
```javascript
// backend/src/config/db.js
const pool = new Pool({
  max: 20,                  // 最大连接数
  idleTimeoutMillis: 30000, // 空闲连接超时
  connectionTimeoutMillis: 2000
});
```

### 7.2 应用层优化

**1. 异步任务队列**：
- AI 分析耗时操作不阻塞前端
- 用户体验流畅

**2. 七牛云 CDN 加速**：
- 图片资源 CDN 分发
- 减少服务器带宽压力

**3. API 响应缓存**：
```javascript
// 患者基本信息缓存 5 分钟
app.get('/api/patients/:id', cache('5 minutes'), async (req, res) => {
  // ...
});
```

### 7.3 前端优化

**1. 组件懒加载**：
```javascript
const DiagnosisReports = () => import('@/views/DiagnosisReports.vue');
```

**2. 图片懒加载**：
```vue
<img v-lazy="imageUrl" />
```

**3. 虚拟滚动**（长列表优化）：
```vue
<el-table-v2 :data="largeDataList" />
```

---

## 8. 安全设计

### 8.1 SQL 注入防护

**参数化查询**：
```javascript
// ✅ 安全
await query('SELECT * FROM patients WHERE patient_id = $1', [id]);

// ❌ 不安全
await query(`SELECT * FROM patients WHERE patient_id = ${id}`);
```

### 8.2 认证与权限

**JWT 认证**：
- 用户登录后签发 Token
- 后续请求携带 Token 访问
- Token 过期时间：24 小时

**权限控制**：
```javascript
// 管理员权限中间件
const adminOnly = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ error: '无权限' });
  }
  next();
};

app.delete('/api/patients/:id', authMiddleware, adminOnly, deletePatient);
```

### 8.3 文件上传安全

**1. 文件类型校验**：
```javascript
const allowedTypes = ['image/jpeg', 'image/png', 'image/jpg'];
if (!allowedTypes.includes(file.mimetype)) {
  throw new Error('不支持的文件类型');
}
```

**2. 文件大小限制**：
```javascript
multer({
  limits: { fileSize: 50 * 1024 * 1024 } // 50MB
});
```

### 8.4 审计日志

**操作日志记录**：
```javascript
// backend/src/utils/audit-log.js
const logAudit = async (userId, action, details) => {
  await query(
    'INSERT INTO audit_logs (user_id, action, details) VALUES ($1, $2, $3)',
    [userId, action, JSON.stringify(details)]
  );
};

// 使用示例
await logAudit(req.user.id, 'CREATE_PATIENT', { patient_id: 123 });
```

### 8.5 环境变量保护

**敏感信息使用环境变量**：
```bash
# .env 文件（不提交到版本控制）
DB_PASSWORD=sensitive_password
QINIU_SECRET_KEY=secret_key
JWT_SECRET=jwt_secret
```

**添加到 .gitignore**：
```
.env
*.log
```

---

## 10. 未来规划

### 10.1 功能扩展

- [ ] 支持更多模态数据（心电图、病理图片）
- [ ] 实时协作功能（多医生会诊）
- [ ] 移动端 APP（React Native）
- [ ] 语音输入病历（ASR 语音识别）

### 10.2 技术优化

- [ ] 引入 Redis 缓存层
- [ ] 微服务架构拆分
- [ ] 消息队列（RabbitMQ）处理异步任务
- [ ] 实时通知（WebSocket）

---

**文档版本**: v1.0
**最后更新**: 2025-10-16
**维护者**: 周佳豪 (jhzhou0704@163.com)
